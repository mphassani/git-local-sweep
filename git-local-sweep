#!/usr/bin/env python3
"""
Git Local Sweep - Clean up local branches that no longer exist on remote.
Similar to git-sweep but for local branches marked as 'gone'.
"""

import subprocess
import sys
import argparse
import urllib.request
import os
import stat
import tempfile
import shutil

VERSION = "1.1.1"
REPO_URL = "https://raw.githubusercontent.com/mphassani/git-local-sweep/main/git-local-sweep"
COMMAND_NAME = os.path.basename(sys.argv[0]) or "git-local-sweep"
NPM_PACKAGE_NAME = "@cryterion/git-local-sweep"
NPM_UPDATE_COMMAND = f"npm install -g {NPM_PACKAGE_NAME}@latest"


def is_npm_package_path(path):
    """Return True when path includes node_modules/@cryterion/git-local-sweep."""
    normalized = os.path.normpath(path)
    parts = normalized.split(os.sep)

    try:
        node_modules_idx = parts.index("node_modules")
    except ValueError:
        return False

    package_parts = parts[node_modules_idx + 1:node_modules_idx + 3]
    return package_parts == ["@cryterion", "git-local-sweep"]


def is_npm_managed_install(script_path, argv_path):
    """Return True if script was launched from an npm-managed install."""
    if is_npm_package_path(script_path):
        return True

    argv_full_path = os.path.abspath(argv_path)
    if is_npm_package_path(argv_full_path):
        return True

    # `npm install -g .` may create a symlink chain where `realpath(__file__)`
    # points to the local workspace file. Inspect first-hop symlink target too.
    if os.path.islink(argv_full_path):
        target = os.readlink(argv_full_path)
        if not os.path.isabs(target):
            target = os.path.normpath(
                os.path.join(os.path.dirname(argv_full_path), target)
            )
        if is_npm_package_path(target):
            return True

    return False


def get_gone_branches():
    """Get list of local branches that are gone from remote."""
    result = subprocess.run(
        ["git", "branch", "-vv"],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        print(f"Error running git branch: {result.stderr}")
        sys.exit(1)
    
    branches = []
    for line in result.stdout.splitlines():
        # Lines with ': gone]' indicate branches no longer on remote
        if ': gone]' in line:
            # Extract branch name (first word, strip leading * if present)
            branch = line.split()[0].lstrip('*')
            branches.append(branch)
    
    return branches


def preview():
    """Preview branches that would be deleted."""
    branches = get_gone_branches()
    
    if not branches:
        print("No local branches are available for cleaning up")
        return
    
    print("These local branches are gone from remote:")
    for branch in branches:
        print(f"  {branch}")
    print(f"\nTo delete them, run again with `{COMMAND_NAME} cleanup`")


def cleanup(force=False):
    """Delete local branches that are gone from remote."""
    branches = get_gone_branches()
    
    if not branches:
        print("No local branches are available for cleaning up")
        return
    
    print("These local branches are gone from remote:")
    for branch in branches:
        print(f"  {branch}")
    
    if not force:
        try:
            response = input("\nDelete these branches? (y/n) ")
            if response.lower() != 'y':
                print("Aborted.")
                return
        except KeyboardInterrupt:
            print("\nAborted.")
            return
    
    print()
    for branch in branches:
        result = subprocess.run(
            ["git", "branch", "-D", branch],
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            print(f"deleting {branch} (done)")
        else:
            print(f"deleting {branch} (failed: {result.stderr.strip()})")
    
    print("\nAll done!")


def check_for_updates():
    """Check if a newer version is available."""
    try:
        with urllib.request.urlopen(REPO_URL) as response:
            content = response.read().decode('utf-8')
            # Extract version from downloaded content
            for line in content.split('\n'):
                if line.startswith('VERSION = '):
                    remote_version = line.split('"')[1]
                    return remote_version
    except Exception as e:
        print(f"Error checking for updates: {e}")
        return None


def update():
    """Update git-local-sweep to the latest version."""
    script_path = os.path.realpath(__file__)

    # npm installs place binaries under node_modules. For that case, delegate
    # updates to npm instead of self-overwriting the script file.
    if is_npm_managed_install(script_path, sys.argv[0]):
        print("This installation is managed by npm.")
        print(f"Run this command to update: {NPM_UPDATE_COMMAND}")
        try:
            response = input("Run it now? (y/n) ")
            if response.lower() == "y":
                result = subprocess.run(NPM_UPDATE_COMMAND.split())
                if result.returncode != 0:
                    print("npm update command failed. Please run it manually.")
                return
            print("Update cancelled.")
        except KeyboardInterrupt:
            print("\nUpdate cancelled.")
        return

    print(f"Current version: {VERSION}")
    print("Checking for updates...")

    remote_version = check_for_updates()
    if not remote_version:
        print("Could not check for updates. Please try again later.")
        return

    if remote_version == VERSION:
        print("You're already running the latest version!")
        return

    print(f"New version available: {remote_version}")

    try:
        response = input("Update now? (y/n) ")
        if response.lower() != 'y':
            print("Update cancelled.")
            return
    except KeyboardInterrupt:
        print("\nUpdate cancelled.")
        return

    # Download the new version
    try:
        print("Downloading update...")
        with urllib.request.urlopen(REPO_URL) as response:
            new_content = response.read()

        # Create a temporary file
        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as temp_file:
            temp_file.write(new_content)
            temp_path = temp_file.name

        # Make the temp file executable
        os.chmod(temp_path, os.stat(script_path).st_mode)

        # Replace the current script with the new version
        shutil.move(temp_path, script_path)

        print(f"âœ“ Successfully updated to version {remote_version}!")
        print(f"Run '{COMMAND_NAME} --version' to verify.")

    except PermissionError:
        print("\nPermission denied. Try running with sudo:")
        print(f"  curl -fsSL {REPO_URL} | sudo tee {script_path} > /dev/null")
        print(f"  sudo chmod +x {script_path}")
    except Exception as e:
        print(f"Error during update: {e}")
        print("\nYou can manually update by running:")
        print(f"  curl -fsSL https://raw.githubusercontent.com/mphassani/git-local-sweep/main/install.sh | bash")


def main():
    parser = argparse.ArgumentParser(
        description="Clean up local branches that no longer exist on remote"
    )
    parser.add_argument(
        "command",
        nargs='?',
        choices=["preview", "cleanup", "update"],
        help="preview: show branches to delete, cleanup: delete them, update: update to latest version"
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Skip confirmation prompt in cleanup"
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"{COMMAND_NAME} {VERSION}"
    )

    args = parser.parse_args()

    # Handle update command (doesn't require git repo)
    if args.command == "update":
        update()
        return

    # Show help if no command provided
    if not args.command:
        parser.print_help()
        return

    # Check if we're in a git repository
    result = subprocess.run(
        ["git", "rev-parse", "--git-dir"],
        capture_output=True
    )
    if result.returncode != 0:
        print("Error: Not a git repository")
        sys.exit(1)

    if args.command == "preview":
        preview()
    elif args.command == "cleanup":
        cleanup(force=args.force)


if __name__ == "__main__":
    main()
